#### 11. "指哪打哪"

解释以下代码的运行结果

```c  
int main(){
    unsigned int x[] = {0x11223344 , 0x55667788 , 0x99aabbcc};
    void *p = x;
    printf("%x\n", *((unsigned char *)p));          
    printf("%x\n", *((unsigned short *)p + 1));  
    printf("%x\n", (*(unsigned short *)p) + 1);   
    printf("%x\n", *((unsigned int *)p + 2));       
    printf("%llx\n", *((unsigned long long *)p));    
    return 0;
}
```

------

| **出题人** | **王家懿**   |
| ---------- | ------------ |
| 知识点1    | 指针类型强转    |
| 知识点2    | 大小端序       |
| 知识点3    | 指针的解引用    |
| 知识点4    | 指针的运算     |

------

Q1.解释一下程序的输出，并说明原因 60%  

Q2.什么是大小端序 20%

Q3.本题中出现了哪些指针的运算规则 20%  


```
A1：
1. 小端序
*((char *)p)
取最低地址 1 字节 → 44
输出：44

*((short *)p + 1)
(short*)p 指向 44 33，+1 后跳过 2 字节，指向 22 11
输出：1122

(*(short *)p) + 1
*(short*)p 取到 3344，再数值加1可得出3345
输出：3345

*((int *)p + 2)
跳过 2 个 int（8 字节），取到 0x99aabbcc
输出：99aabbcc

*((long long *)p)
取前 8 个字节（两个 int 拼起来）：0x55667788 11223344（小端: 低位 11223344, 高位 55667788）
输出：5566778811223344

2. 大端序
0x11223344 在内存中的存储顺序：

低地址 → 高地址: 11 22 33 44

同理：

0x55667788 → 55 66 77 88
0x99aabbcc → 99 aa bb cc

*((char *)p)
取最低地址 1 字节 → 11
输出：11

*((short *)p + 1)
(short*)p 指向 11 22，+1 后跳过 2 字节，指向 33 44
输出：3344

(*(short *)p) + 1
*(short*)p 取到 1122，再数值加1就得出1123
输出：1123

*((int *)p + 2)
跳过 2 个 int，取到 0x99aabbcc
输出：99aabbcc

*((long long *)p)
取前 8 个字节：0x11223344 55667788（大端: 低位 11223344, 高位 55667788）
输出：1122334455667788
  
A2：
小端序 ： 低字节存在低地址，高字节存在高地址。
大端序 ： 高字节存在低地址，低字节存在高地址。
在本题中，0x11223344 在小端存储为 44 33 22 11，在大端存储为 11 22 33 44，因此相同的指针运算在不同机器上输出结果会不同。

A3：
1. 强制类型转换

2. 指针加法运算
ptr + n → 地址实际偏移 n * sizeof(*ptr) 个字节
例如 (short*)p + 1 实际跳过 2 个字节

3. 解引用运算 *
*(short*)p 表示取出 2 字节并组成 short 类型的数值

4. 算术运算与指针运算的区别
(*(short*)p) + 1: 取值后再进行数值加法
((short*)p + 1): 指针加法，改变地址位置，再解引用