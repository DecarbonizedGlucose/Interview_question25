#### 12. 奇怪的循环

你能看明白这个程序怎样运行吗？试着理解这个程序吧！

```c
//在 64 位系统，默认最大对齐数为 8 的情况下
union data {
    void **** p;
    char arr[20];
};

typedef struct node {
    int a;
    union data b;
    void (*use)( struct node *n);
    char string[0];
} Node;

void func1(Node *node);
void func2(Node *node);

void func1(Node *node) {
    node->use = func2;
    printf("%s\n", node->string);
}

void func2(Node *node){
    node->use = func1;
    printf("%d\n", ++(node->a));
}

int main() {
    const char *s = "Your journey begins here!";
    Node *P = (Node *)malloc(sizeof(Node) + (strlen(s) + 1) * sizeof(char));
    strcpy(P->string, s);
    P->use = func1;
    P->a = sizeof(Node)*50 + sizeof(union data);
    while(P->a < 2028){
        P->use(P);
    }
    free(P);
    return 0;
}
```

------

| **出题人** | **王柯**   |
| ---------- | ------------ |
| 知识点1    | union与struct的内存对齐 |
| 知识点2    | 函数的声明与函数指针 |
| 知识点3    | 结构体指针与函数指针的运用 |
| 知识点4    | malloc、free |
| 知识点5    | 柔性数组 |

------

Q1.计算union data和struct node的大小。 30% （各15%）

Q2.讲讲malloc和free。 20%

Q3.从P->use = func1;开始，讲完main函数中while内部逻辑，内部是怎样运行的？输出什么？ 30% （尤其是函数指针的赋值与调用）

Q4.struct node中的0长数组有什么作用？ 10%

Q5.struct node类型定义下方的void func1(Node *node);和void func2(Node *node);是什么？去除后程序还能运行吗？ 10%

```

A1：
联合体内存的分配：
    1. 大小足够容纳最宽的成员；
    2. 大小能被其包含的所有基本数据类型的大小所整除。
由第一条，data的内存至少为20字节，需要与8字节的指针对齐，则data大小为24。

sizeof Node大小的计算：
    int a;              4字节
                        给union data b对齐4字节
    union data b;       24字节，对齐数为8
    xxx (*use)(xxx);    函数指针，8字节
    char string[0];     不占空间
故合计40字节。

A2：
malloc(size_t size)：从堆上分配一块连续的内存区域，大小为 size 字节，返回 void* 指针。若失败返回 NULL。分配的内存内容未初始化。
free：释放之前用 malloc 分配的内存，把这块内存还给堆，避免内存泄漏。free 只能释放由 malloc/calloc/realloc 分配的指针，不能释放局部变量的地址。
      free 后的指针变为悬空指针，最好置为 NULL。
A3：
运行逻辑：
    P->use = func1;     func1为函数名，也是函数指针，这里将其赋值给结构体指针P指向的函数指针。
    P->a经过计算赋值为2024。
    
    while(P->a < 2028){
        P->use(P);
    }                   该循环中，P->use()是调用结构体P中函数指针指向的函数，use(P)这里括号内部的P作为该函数的参数。
    在func1中
    void func1(Node *node) {
        node->use = func2;                  这里将func2赋值给结构体指针node指向的函数指针。
        printf("%s\n", node->string);       输出结构体指针node指向的字符数组内容（即为"Your journey begins here!"）
    }
    func1执行完毕后，由于P->a还是一开始计算的2024，继续while(P->a < 2028)的循环，但此时P->use已经被赋值为fuc2，因此此次会调用func2函数。
    在func2中
    void func2(Node *node){
        node->use = func1;                  这里将func1赋值给结构体指针node指向的函数指针。
        printf("%d\n", ++(node->a));        输出先置自增的node->a，a从2024开始，则输出从2025开始。
    }
    func2执行完毕后，P->a为2025，继续循环，但此时调用fucn1函数，输出字符数组内容后调用func2函数，输出2026，以此往复，直到P->a为2027时，输出2028，然后离开循环。
运行后输出的内容：
Your journey begins here!
2025
Your journey begins here!
2026
Your journey begins here!
2027
Your journey begins here!
2028

A4：
char string[0];是柔性数组。
用于在结构体结尾扩展存放变长数据。
这里 malloc(sizeof(Node) + strlen(s)+1)，额外分配空间给 string，从而能在 Node 内直接存储动态字符串。
好处：
避免二次分配内存，节省内存，提高缓存友好性。

A5：
func1、func2 是函数声明，如果去除，由于func1和func2会互相调用，总会导致函数1因为定义在函数2下方，导致函数2内部调用函数1时找不到其定义，报错。而先声明两个函数则不会出现这个问题。