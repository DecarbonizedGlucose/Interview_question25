## 11.指针魔法
请解释以下代码的运行结果，并说明每一步的原因。

```c
void foo(int (*pa)[6], int **pp) {
    **pp += (*pa)[2];           
    *pp   = (*pa) + 5;          
    **pp -= (*pa)[0];           
    *pp   = (*pa) + ((*(*pa+3) & 1) ? 3 : 1);
    *(*pp) += *(*pp - 1);       
    *pp   = (*pa) + 2;          
}

int main(void) {
    int a[6] = {2, 4, 6, 8, 10, 12};
    int *p   = a + 1;   
    int **pp = &p;

    foo(&a, pp);

    printf("%d\n", *p);
    printf("%d\n", **pp);
    printf("%d\n", a[1]);
    printf("%d\n", a[3]);
    printf("%d\n", a[5]);
    printf("%d\n", a[2]);
    printf("%td\n", p - a);
    return 0;
}
```
---
| **出题人** | **井光成**                                |
| ------- | ------------------------------------- |
| 知识点1    | 指向数组的指针 `int (*pa)[N]`           |
| 知识点2    | 二级指针 `int **pp`、通过指针修改外部变量            |
| 知识点3    | 指针算术与下标/解引用优先级：`(*pa)[i]`、`*(*pa+3)`  |
| 知识点4    | 条件运算符 `?:`、按位与 `&` 的结合与求值             |
| 知识点5    | 指针差 `p - a` 的含义 |
---
Q1：传值和传址的区别，若想修改指针的值，该如何做
Q2：为什么将数组作为参数传入函数，却能修改原数组的内容？不应该是应该传入指针吗
Q3：`p-a`的含义
Q4：最好不要随便进行传址返回，为什么？
```
A1：传值相当于拷贝了一个临时变量，不会修改原变量的值，传址传的则是原变量的地址，对此地址处进行修改，也就修改了原变量
A2：在 C 语言里，数组名在大多数情况下并不是一个“真正的数组值”，而是会 自动转换为指针，指向数组开头的元素
A3：以数组元素大小为单位的距离
A4：在函数中创建的变量都是临时变量，会随着函数调用的结束一同销毁，此时该变量的地址已经不合法，若传址返回并对此地址进行使用，可能会发生不可预见的未知错误，即使是动态申请在堆上的内存空间使用传址返回也有可能发生双重释放的错误，可维护性差
```
附加题：寄存器是什么？你是否了解函数栈帧的创建与销毁？函数调用的过程？main函数是否是程序中第一个函数
