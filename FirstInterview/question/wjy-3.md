#### 3.到底等不等

为什么运算结果与我们想的不一样呢，尝试解释一下原理。

```c
int main() {
    float a = 1e-1 , b = 1e-2;
    double A = 1e-1 , B = 1e-2;
    printf("    a==A      is %s\n",a-A == 0 ? "true" : "false");
    printf("  a-b==A-B    is %s\n",a-b == A-B ? "true" : "false");
    int temp1 = a * 10,temp2 = A * 10;
    printf("temp1==temp2  is %s\n",temp1 == temp2 ? "true" : "false");
}
```

------

| **出题人** | **王家懿**   |
| ---------- | ------------ |
| 知识点1    | 强制类型转换 |
| 知识点2    | 科学记数法   |
| 知识点3    | 浮点数比较   |
| 知识点4    | 浮点数精度   |

------

Q1.解释一下每一个printf的输出 40%  

Q2.解释为什么浮点数计算会不精确 30%

Q3.有哪些方法可以判断浮点数之间是否相等 30%  


```
A1：
1. false，首先在二元运算或者比较运算中，如果两个操作数类型不同，较低精度的类型会被提升到较高精度。  
当 a 转换为 double 与 A 比较时，二者由于精度不同不完全相等  
2. false，与1类似  
3. true，二者在转为int时都被截断为整数1了，因此相等

A2：
1. 二进制表示的限制  
很多十进制小数（如 0.1、0.01）在二进制中是无限循环小数，计算机只能存储有限位数 → 只能近似表示。

2. 精度有限  
float 只有 23 位尾数位（约 7 位有效十进制数）。  
double 有 52 位尾数位（约 15~16 位有效十进制数）。  
当计算结果超出可表示范围时，尾部数字被截断或四舍五入，导致误差。

3. 运算误差传播  
多次加减乘除会让误差不断累积，最终结果与数学理想值不同。    

A3：
1. 误差范围法  
将两个浮点数之间做差，小于某一个值时就可认为两个数相等  
2. 整数代替  
将小数统一放大为整数来进行计算
```
