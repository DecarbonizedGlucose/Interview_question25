#### 3. 数学没问题，浮点数有鬼

~~~c
int main() {
    float a1 = 0.3, b1 = 6e-1, sum1 = 0.9;
    printf("a1 + b1 %s sum1\n", (a1+b1==sum1) ? "==" : "!=");
    float a2 = 0x0.3p0, b2 = 0x6p-4, sum2 = 0x0.9p0;
    printf("a2 + b2 %s sum2\n", (a2+b2==sum2) ? "==" : "!=");
}
~~~

头文件略。这个程序的输出是什么？解释为什么会这样？



------

| 出题人  | 张若水             |
| ------- | ------------------ |
| 知识点1 | 浮点数不同表示形式 |
| 知识点2 | 浮点数存储和精度   |
| 知识点3 | 三元操作符 |



------

Q1. 说明`a1`,`a2`,`b1`,`b2`,`sum1`,`sum2`的大小，并解释c语言浮点数的表示形式 (40%, 20% + 20%)

Q2. 说明程序会输出什么，并解释原因 (50%)

Q3. 解释三元操作符的用法 (10%)

~~~
A1:
a1=0.3，由于使用二进制存储，对0.3,0,6这样的数字无法精确存储，只会无限逼近，
二进制位形如0.010011001100...。而0x0.3p0是十六进制数，就是0.1875，二进制数位即0.0011
sum同理。
十进制浮点数：x[.y][ez]，如1.2e-3;十六进制浮点数:0xa[.b]pc，必须带有p幂指数，如0xff.7ap-3。
幂指数均以十进制整数书写。

A2:
a1 + b1 != sum1
a2 + b2 == sum2
原因：本题中十进制小数有存储精度问题，计算后误差较大，出现不相等情况。
十六进制数可以完美存储，不会出现精度问题。

A3:
用法：val = cond ? expr1 : expr2; 三元操作符返回一个临时的右值，用作左值是不合法的操作。

~~~

