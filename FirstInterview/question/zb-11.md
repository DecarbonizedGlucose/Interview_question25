#### 11.小小 char，大大 gap

这面魔法镜子映照的不只是外表，还有结构体内部的内存秘密。请观察输出，揭开对齐和填充的谜团：

```c
struct MagicMirror {
    char spell;     // 魔法咒语
    int power;      // 魔力值
    char potion;    // 魔药
    double energy;  // 能量值
};

int main() {
    struct MagicMirror mirror = {'A', 42, 'B', 3.14};
    char *magic_ptr = (char*)&mirror;

    printf("镜子大小: %zu 字节\n", sizeof(mirror));

    for(int i = 0; i < sizeof(mirror); i++) {
        printf("位置%d: 0x%02X (%c)\n", 
               i, 
               (unsigned char)magic_ptr[i], 
               (magic_ptr[i] >= 32 && magic_ptr[i] <= 126) ? magic_ptr[i] : '?');
    }

    // 偷窥成员的地址
    printf("spell 地址: %p\n", (void*)&mirror.spell);
    printf("power 地址: %p\n", (void*)&mirror.power);
    printf("potion 地址: %p\n", (void*)&mirror.potion);
    printf("energy 地址: %p\n", (void*)&mirror.energy);

    return 0;
}
```

------

| **出题人** | **朱斌**   |
| ---------- | ------------ |
| 知识点1    | 结构体内存对齐 |
| 知识点2    | 填充字节   |
| 知识点3    | 指针偏移与成员地址    |

------


Q1. 为什么结构体的大小不是 1+4+1+8=14 字节，而是更大？40%

Q2. 如果把 double energy 移到最前面，结构体大小会发生变化吗？为什么？25%

Q3. 从打印的成员地址中，你能发现什么规律？为什么 power 并不是紧跟在 spell 后面？为什么 potion 和 energy 之间也有空隙？20%

Q4. 用自己的话解释“内存对齐”和“填充字节（padding）”是什么意思，为什么需要它？15%

```
A1：
结构体大小受到 内存对齐 影响。编译器会为每个成员按照其类型对齐（int 按 4 字节，double 按 8 字节），中间会插入填充字节，最终 sizeof(mirror) 通常是 24，而不是 14。

A2：
如果把 double energy 放到最前面，它自然按 8 字节对齐，减少填充字节，结构体大小可能减小（例如 16 字节），取决于编译器对齐规则。

A3：
成员地址显示规律：  
- 每个成员的地址是其类型所需对齐倍数的整数倍。  
- power 并不是紧跟 spell 后面，因为在 char 后面需要插入填充，使 int 对齐。  
- potion 后也插入填充，使 double 按 8 字节对齐。

A4：
内存对齐：数据在内存中的地址必须满足特定倍数（通常是类型大小），以便 CPU 高效访问。  
填充字节（padding）：为了满足对齐要求而在成员之间插入的额外空间。
```